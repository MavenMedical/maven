Database Utils:

dbconfig.py : This is the configuration file that the db_utils.py reads from to get the connection parameters as well as table maps
so we can create objects after querying that contain column information. (So we don't have to set values based on list index)

db_utils: all the utilities

    connect(): uses psycopg2 and dbconfig file to create connection
    disconnect(): destroys the cursor (if it exists) and then closes the connection
    create_cursor(): creates ONE cursor after the connection has been made
    destroy_cursor(): destroys the cursor

    I have been having trouble using the asyncio library. Currently the "blocking functions" use a task that sets a future
    but I think these functions are unnecessary, they exist because I was trying to use the same co routines for
    blocking and non blocking calls.

    query_database_read_blocking(query,queryMap=None): calls query_database_read(query,queryMap=None)
        - execute query, if we define a mapping that we want to use to accumualate the results, map each column to the value for that column
        - otherwise just send back the results in a list

    query_database_write_blocking(query): calls query_database_write(query)
        - executes the query

    select_rows_from_map: a helper method to create a string for a query based on the Mapping we are going to use for the query
    For example: we have a Mapping= ["col1","col2","col3"], then we want the string "col1,col2,col3" for the query

    the helper method is used in the example below from unit_test_db
    queryParameters = db_utils.select_rows_from_map(RULE_TABLE_MAPPING)
    res = db_utils.query_database_read_blocking("SELECT %s FROM ruleTest.rules WHERE orderedCPT = 12345" % queryParameters, RULE_TABLE_MAPPING)


    still need to implement the non blocking methods but fist understand the asyncio library better

